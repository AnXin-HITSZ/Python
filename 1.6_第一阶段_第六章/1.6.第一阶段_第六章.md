# 第一阶段 - 第六章：Python 数据容器

**目录：**

[TOC]

---

## 一、数据容器入门

数据容器可以优雅、高效地通过一个变量完成记录多份数据的任务，即一个容器可以容纳多份数据。

学习数据容器，就是为了批量存储或批量使用多份数据。

Python 中的数据容器是一种可以容纳多份数据的数据类型，容纳的每一份数据称之为 1 个元素，每一个元素可以是任意类型的数据，如字符串、数字、布尔等。数据容器如下图所示：
![](./images/20251001165320.png)

数据容器根据特点的不同，如是否支持重复元素、是否可以修改、是否有序等，分为 5 类，分别是：列表（`list`）、元组（`tuple`）、字符串（`str`）、集合（`set`）、字典（`dict`）。它们各有特点，但都满足可容纳多个元素的特性。

## 二、列表（list）

### 2.1 列表的定义语法

列表（`list`）类型，是数据容器的一类。

列表的定义的基本语法：
```python
# 字面量
[元素 1, 元素 2, 元素 3, 元素 4, ...]

# 定义变量
变量名称 = [元素 1, 元素 2, 元素 3, 元素 4 ...]

# 定义空列表
变量名称 = []
变量名称 = list()
```

列表内的每一个数据，称之为元素。

> 注意：
> * 列表以 `[]` 作为标识；
> * 列表内每一个元素之间用逗号（`,`）隔开。

列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套。

> 注意：列表内的元素的数据类型没有任何限制，甚至元素也可以是列表，这样就定义了嵌套列表。

示例代码 1：
```python
name_list = ['itheima', 'itcast', 'python']
print(name_list)
print(type(name_list))
```
输出结果：
```python
['itheima', 'itcast', 'python']
<class 'list'>
```

示例代码 2：
```python
my_list = ['itheima', 666, True]
print(my_list)
print(type(my_list))
```
输出结果：
```python
['itheima', 666, True]
<class 'list'>
```

示例代码 3：
```python
# 嵌套列表的定义
my_list = [[1, 2, 3], [4, 5, 6]]
print(my_list)
print(type(my_list))
```
输出结果：
```python
[[1, 2, 3], [4, 5, 6]]
<class 'list'>
```

### 2.2 列表的下标索引

我们可以使用下标索引从列表中取出特定位置的数据。

![](./images/20251002151837.png)

如上图所示，列表中的每一个元素，都有其位置下标索引；从前向后的方向，位置下标索引从 0 开始，且依次递增。

我们只需要按照下标索引，即可取得对应位置的元素：
```python
列表[下标索引]
```
示例代码：
```python
# 语法：列表[下标索引]

name_list = ['Tom', 'Lily', 'Rose']
print(name_list[0]) # 结果：Tom
print(name_list[1]) # 结果：Lily
print(name_list[2]) # 结果：Rose
```

或者，可以使用反向索引，也就是从后向前的方向，位置下标索引从 -1 开始，依次递减（-1、-2、-3 ……）

![](./images/20251002152450.png)

如上图所示，从后向前，下标索引为 -1、-2、-3 ……，且依次递减。

我们也只需要按照下标索引，即可取得对应位置的元素：
```python
列表[标号]
```
示例代码：
```python
# 语法：列表[标号]

name_list = ['Tom', 'Lily', 'Rose']
print(name_list[-1])    # 结果：Rose
print(name_list[-2])    # 结果：Lily
print(name_list[-3])    # 结果：Tom
```

如果列表是嵌套的列表，同样支持下标索引：
![](./images/20251002153030.png)

如上图所示，下标就有 2 个层级了：
```python
# 2 层嵌套 list
my_list = [[1, 2, 3], [4, 5, 6]]

# 获取内层第一个 list
print(my_list[0])   # 结果：[1, 2, 3]

# 获取内层第一个 list 的第一个元素
print(my_list[0][0])    # 结果：1
```

> 下标索引的注意事项：要注意下标索引的取值范围，超出范围无法取出元素，并且会报错。

### 2.3 列表的常用操作方法

列表除了可以定义、使用下标索引获取值以外，列表也提供了插入元素、删除元素、清空列表、修改元素、统计元素个数等等一系列功能，这些功能我们都称之为列表的方法。

列表的方法 - 总览：
| 编号 | 使用方式 | 作用 |
| :--: | :--: | :--: |
| 1 | `列表.append(元素)` | 向列表中追加一个元素 |
| 2 | `列表.extend(容器)` | 将数据容器的内容依次取出，追加到列表尾部 |
| 3 | `列表.insert(下标, 元素)` | 在指定下标处，插入指定的元素 |
| 4 | `del 列表[下标]` | 删除列表指定下标元素 |
| 5 | `列表.pop(下标)` | 删除列表指定下标元素 |
| 6 | `列表.remove(元素)` | 从前向后，删除此元素第一个匹配项 |
| 7 | `列表.clear()` | 清空列表 |
| 8 | `列表.count(元素)` | 统计此元素在列表中出现的次数 |
| 9 | `列表.index(元素)` | 查找指定元素在列表的下标，找不到报错 `ValueError` |
| 10 | `len(列表)` | 统计容器内有多少元素 |

回忆：函数是一个封装的代码单元，可以提供特定功能。

在 Python 中，如果将函数定义为 `class`（类）的成员，那么函数会称之为方法：
![](./images/20251002155136.png)

方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同：
* 函数的使用：
    ```python
    num = add(1, 2)
    ```
* 方法的使用：
    ```python
    student = Student()
    num = student.add(1, 2)
    ```

关于类和方法的定义，在面向对象章节我们学习，目前我们知道如何使用方法即可。

#### 2.3.1 列表的查询功能（方法）

查找某元素的下标：
* 功能：查找指定元素在列表的下标，如果找不到，报错 `ValueError`。
* 语法：`列表.index(元素)`。
> `index` 就是列表对象（变量）内置的方法（函数）。
* 示例代码：
    ```python
    my_list = ["itheima", "itcast", "python"]
    print(my_list.index("itcast"))  # 结果：1
    ```

#### 2.3.2 列表的修改功能（方法）

修改特定位置（索引）的元素值：
* 功能：直接对指定下标（正向、反向下标均可）的值进行重新赋值（修改）。
* 语法：`列表[下标] = 值`。
* 示例代码：
    ```python
    # 正向下标
    my_list = [1, 2, 3]
    my_list[0] = 5
    print(my_list)  # 结果：[5, 2, 3]

    # 反向下标
    my_list = [1, 2, 3]
    my_list[-3] = 5
    print(my_list)  # 结果：[5, 2, 3]
    ```

插入元素：
* 功能：在指定的下标位置，插入指定的元素。
* 语法：`列表.insert(下标, 元素)`。
* 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_list.insert(1, "itheima")
    print(my_list)  # 结果：[1, "itheima", 3, 4]
    ```

追加元素：
* 方式 1：
  * 功能：将指定元素，追加到列表的尾部。
  * 语法：`列表.append(元素)`。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_list.append(4)
    print(my_list)  # 结果：[1, 2, 3, 4]

    my_list = [1, 2, 3]
    my_list.append([4, 5, 6])
    print(my_list)  # 结果：[1, 2, 3, [4, 5, 6]]
    ```
* 方式 2：
  * 功能：将其他数据容器的内容取出，依次追加到列表尾部。
  * 语法：`列表.extend(其他数据容器)`。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_list.extend([4, 5, 6])
    print(my_list)  # 结果：[1, 2, 3, 4, 5, 6]
    ```

删除元素：
* 语法 1：`del 列表[下标]`。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]

    # 方式 1
    del my_list[0]
    print(my_list)  # 结果：[2, 3]
    ```
* 语法 2：`element = 列表.pop(下标)`。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]

    # 方式 2
    my_list.pop(0)
    print(my_list)  # 结果：[2, 3]
    ```

删除某元素在列表中的第一个匹配项：
* 语法：`列表.remove(元素)`。
* 示例代码：
    ```python
    my_list = [1, 2, 3, 2, 3]
    my_list.remove(2)
    print(my_list)  # 结果：[1, 3, 2, 3]
    ```

清空列表内容：
* 语法：`列表.clear()`。
* 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_list.clear()
    print(my_list)  # 结果：[]
    ```

#### 2.3.3 列表的查询功能（方法）

统计某元素在列表内的数量：
* 语法：`列表.count(元素)`。
* 示例代码：
    ```python
    my_list = [1, 1, 1, 2, 3]
    print(my_list.count(1)) # 结果：3
    ```

统计列表内有多少元素：
* 功能：可以得到一个 `int` 数字，表示列表内的元素数量。
* 语法：`len(列表)`。
* 示例代码：
```python
my_list = [1, 2, 3, 4, 5]
print(len(my_list)) # 结果：5
```

### 2.4 列表的循环遍历

既然数据容器可以存储多个元素，那么，就会有需求从容器内依次取出元素进行操作。

将容器内的元素依次取出进行处理的行为，称之为：遍历、迭代。

#### 2.4.1 列表的遍历 - while 循环

如何遍历列表的元素呢？
* 可以使用前面学过的 `while` 循环。

如何在循环中取出列表的元素呢？
* 使用 `列表[下标]` 的方式取出。

循环条件如何控制？
* 定义一个变量表示下标，从 0 开始；
* 循环条件为 `下标值 < 列表` 的元素数量。

示例代码：
```python
index = 0
while index < len(列表):
    元素 = 列表[index]
    对元素进行处理
    index += 1
```

#### 2.4.2 列表的遍历 - for 循环

除了 `while` 循环外，Python 中还有另外一种循环形式：`for` 循环。
对比 `while`，`for` 循环更加适合对列表等数据容器进行遍历。

`for` 循环遍历列表的语法：
```python
for 临时变量 in 数据容器:
    对临时变量进行处理
```
上述代码表示从容器内依次取出元素并赋值到临时变量上；在每一次的循环中，我们可以对临时变量（元素）进行处理。

示例代码：
```python
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    print(i)
```
输出结果：
```python
1
2
3
4
5

```
对于上述示例代码，每一次循环将列表中的元素取出，赋值到变量 `i`，供操作。

#### 2.4.3 while 循环和 for 循环的对比

`while` 循环和 `for` 循环，都是循环语句，但细节不同：
* 在循环控制上：
  * `while` 循环可以自定循环条件，并自行控制；
  * `for` 循环不可以自定循环条件，只可以一个个从容器内取出数据。
* 在无限循环上：
  * `while` 循环可以通过条件控制做到无限循环；
  * `for` 循环理论上不可以，因为被遍历的容器容量不是无限的。
* 在使用场景上：
  * `while` 循环适用于任何想要循环的场景；
  * `for` 循环适用于遍历数据容器的场景或简单的固定次数循环场景。

> 总结：
> * `for` 循环更简单，`while` 循环更灵活；
> * `for` 循环用于从容器内依次取出元素并处理，`while` 循环用以任何需要循环的场景。

### 2.5 列表总结

经过上述对列表的学习，可以总结出列表有如下特点：
* 可以容纳多个元素（上限为 2 ** 63 - 1，即 9223372036854775807 个）；
* 可以容纳不同类型的元素（混装）；
* 数据是有序存储的（有下标序号）；
* 允许重复数据存在；
* 可以修改（增加或删除元素等）。

## 三、元组（tuple）

思考：列表是可以修改的；如果想要传递的信息不被篡改，列表就不合适了。

元组同列表一样，都是可以封装多个、不同类型的元素在内；但最大的不同点在于：元组一旦定义完成，就不可修改。

所以，当我们需要在程序内封装数据，又不希望封装的数据被篡改，那么元组就非常合适了。

### 3.1 定义元组

元组定义：定义元组使用小括号，且使用逗号隔开各个数据，数据可以是不同的数据类型。
示例代码：
```python
# 定义元组字面量
(元素, 元素, 元素, ..., 元素)

# 定义元组变量
变量名称 = (元素, 元素, ..., 元素)

# 定义空元组
变量名称 = ()   # 方式 1
变量名称 = tuple()  # 方式 2（得到元组的类对象）
```

元组也支持嵌套：
```python
# 定义一个嵌套元组
t1 = ((1, 2, 3), (4, 5, 6))
print(t1[0][0]) # 结果：1
```

> 注意：
> ```python
> # 定义 3 个元素的元组
> t1 = (1, 'Hello', True)
> 
> # 定义 1 个元素的元组
> t2 = ('Hello', )  # 注意：必须带有逗号，否则不是元组类型
> ```
> 如上述代码所示，当元组只有一个数据时，这个数据后面要添加逗号。

### 3.2 元组的相关操作

元组由于不可修改的特性，所以其操作方法非常少：
| 编号 | 方法 | 作用 |
| :--: | :--: | :--: |
| 1 | `index()` | 查找某个数据，如果数据存在返回对应的下标，否则报错 |
| 2 | `count()` | 统计某个数据在当前元组出现的次数 |
| 3 | `len(元组)` | 统计元组内的元素个数 |

示例代码：
```python
# 根据下标（索引）取出数据
t1 = (1, 2, 'hello')
print(t1[2])    # 结果：'hello'

# 根据 index()，查找特定元素的第一个匹配项
t1 = (1, 2, 'hello', 3, 4, 'hello')
print(t1.index('hello'))    # 结果：2

# 统计某个数据在元组内出现的次数
t1 = (1, 2, 'hello', 3, 4, 'hello')
print(t1.count('hello'))    # 结果：2

# 统计元组内的元素个数
t1 = (1, 2, 3)
print(len(t1))  # 结果：3
```

注意事项：
* 不可以修改元组的内容，否则会直接报错：
  * 错误示例：
    ```python
    # 尝试修改元组内容
    t1 = (1, 2, 3)
    t1[0] = 5
    ```
    * 输出结果：
        ![](./images/20251003113310.png)
* 可以修改元组内的 `list` 的内容（修改元素、增加、删除、反转等）：
  * 示例代码：
    ```python
    # 尝试修改元组内容
    t1 = (1, 2, ['itheima', 'itcast'])
    t1[2][1] = 'best'
    print(t1)   # 结果：(1, 2, ['itheima', 'best'])
    ```
* 不可以替换 `list` 为其他 `list` 或其他类型：
  * 错误示例：
    ```python
    # 尝试修改元组内容
    t1 = (1, 2, ['itheima', 'itcast'])
    t1[2] = [1, 2, 3]
    print(t1)
    ```
    * 输出结果：
        ![](./images/20251003113930.png)

### 3.3 元组的遍历

同列表一样，元组也可以被遍历。

可以使用 `while` 循环和 `for` 循环遍历它：
* while 循环：
```python
my_tuple = (1, 2, 3, 4, 5)
index = 0
while index < len(my_tuple):
    print(my_tuple(index))
    index += 1
```
* for 循环：
```python
my_tuple = (1, 2, 3, 4, 5)
for i in my_tuple:
    print(i)
```

上述两种循环遍历方式的输出结果均为：
```python
1
2
3
4
5

```

### 3.4 元组总结

经过上述对元组的学习，可以总结出元组有如下特点：
* 可以容纳多个数据；
* 可以容纳不同类型的数据（混装）；
* 数据是有序存储的（下标索引）；
* 允许重复数据存在；
* 不可以修改（增加或删除元素等）；
* 支持 `for` 循环。

多数特性和 `list` 一致，不同点在于不可修改的特性。

## 四、字符串（str）

### 4.1 再识字符串

尽管字符串看起来并不像列表、元组那样一看就是存放了许多数据的容器；但不可否认的是，字符串同样也是数据容器的一员。

字符串是字符的容器，一个字符串可以存放任意数量的字符。如，字符串 `"itheima"`：
![](./images/20251003151843.png)

> 字符串为什么被称之为数据容器呢？
> * 字符串可以看做是字符的容器，支持下标索引等特性。

### 4.2 字符串的下标（索引）

和其他容器如列表、元组一样，字符串也可以通过下标进行访问：
* 从前向后，下标从 0 开始；
* 从后向前，下标从 -1 开始。

示例代码：
```python
# 通过下标获取特定位置字符
name = "itheima"
print(name[0])  # 结果：i
print(name[-1]) # 结果：a
```

同元组一样，字符串是一个无法修改的数据容器。所以，修改指定下标的字符（如 `字符串[0] = "a"`）、移除特定下标的字符（如 `del 字符串[0]`、`字符串.remove()`、`字符串.pop()` 等）、追加字符等（如 `字符串.append()`）均无法完成。如果必须要做，只能得到一个新的字符串，旧的字符串是无法修改。

### 4.3 字符串的常用操作

查找特定字符串的下标索引值：
* 语法：`字符串.index(字符串)`。
* 示例代码：
  ```python
  my_str = "itcast and itheima"
  print(my_str.index("and"))  # 结果：7
  ```

字符串的替换：
* 功能：将字符串内的全部 `字符串 1` 替换为 `字符串 2`。
* 语法：`字符串.replace(字符串 1, 字符串 2)`。
* 示例代码：
  ```python
  name = "itheima itcast"
  new_name = name.replace("it", "传智")

  print(new_name) # 结果：传智heima 传智cast
  print(name) # 结果：itheima itcast
  ```
> 注意：字符串的替换不是修改字符串本身，而是得到了一个新字符串。
> 
> 通过上述的示例代码可以看到，字符串 `name` 本身并没有发生变化，而是得到了一个新字符串对象。

字符串的分割：
* 功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中。
* 语法：`字符串.split(分隔符字符串)`。
* 示例代码：
  ```python
  name = "传智播客 传智教育 黑马程序员 博学谷"
  name_list = name.split(" ")

  print(name_list)  # 结果：['传智播客', '传智教育', '黑马程序员', '博学谷']
  print(type(name_list))  # 结果：<class 'list'>
  ```
> 注意：字符串进行分割操作后，字符串本身不变，而是得到了一个列表对象。
>
> 通过上述的示例代码可以看到，字符串按照给定的 <空格> 进行了分割，变成多个子字符串，并存入一个列表对象中。

字符串的规整操作：
* 去前后空格以及回车符：
  * 语法：`字符串.strip()`。
  * 示例代码：
    ```python
    my_str = "  itheima and itcast  "
    print(my_str.strip()) # 结果："itheima and itcast"
    ```
* 去前后指定字符串：
  * 语法：`字符串.strip(字符串)`。
  * 示例代码：
    ```python
    my_str = "12itheima and itcast21"
    print(my_str.strip("12")) # 结果："itheima and itcast"
    ```
> 注意：传入的是 `"12"`，其实就是 `"1"` 和 `"2"` 都会移除，即是按照传入的字符串的单个字符查询并移除。

统计字符串中某字符串的出现次数：
* 语法：`字符串.count(字符串)`。
* 示例代码：
  ```python
  my_str = "itheima and itcast"
  print(my_str.count("it")) # 结果：2
  ```

统计字符串的长度：
* 语法：`len(字符串)`。
* 示例代码：
  ```python
  my_str = "1234 abcd !@#$ 黑马程序员"
  print(len(my_str))  # 结果：20
  ```
> 注意：通过上述的示例代码可以看出，数字（`1`、`2`、`3` ……）、字母（`abcd`、`ABCD` 等）、符号（`空格`、`!`、`@`、`#`、`$` 等）、中文均算作 1 个字符。

综上所述，字符串常用操作汇总如下：
| 编号 | 操作 | 说明 |
| :--: | :--: | :--: |
| 1 | `字符串[下标]` | 根据下标索引取出特定位置字符 |
| 2 | `字符串.index(字符串)` | 查找给定字符的第一个匹配项的下标 |
| 3 | `字符串.replace(字符串 1, 字符串 2)` | 将字符串内的全部 `字符串 1` 替换为 `字符串 2`（不会修改原字符串，而是得到一个新的字符串） |
| 4 | `字符串.split(字符串)` | 按照给定字符串，对字符串进行分隔（不会修改原字符串，而是得到一个新的列表） |
| 5 | `字符串.strip()` 或 `字符串.strip(字符串)` | 移除首尾的空格和换行符或指定字符串 |
| 6 | `字符串.count(字符串)` | 统计字符串内某字符串的出现次数 |
| 7 | `len(字符串) `| 统计字符串的字符个数 |

### 4.4 字符串的遍历

同列表、元组一样，字符串也支持 `while` 循环和 `for` 循环进行遍历：
* `while` 循环遍历字符串：
```python
my_str = "黑马程序员"
index = 0
while index < len(my_str):
  print(my_str[index])
  index += 1
```
* `for` 循环遍历字符串：
```python
my_str = "黑马程序员"
for i in my_str:
  print(i)
```

上述两种循环遍历方式的输出结果均为：
```python
黑
马
程
序
员

```

### 4.5 字符串总结

作为数据容器，字符串有如下特点：
* 只可以存储字符串；
* 长度任意（取决于内存大小）；
* 支持下标索引；
* 允许重复字符串存在；
* 不可以修改（增加或删除元素等）；
* 支持 `for` 循环。

字符串基本和列表、元组相同。不同于列表和元组之处在于字符串容器可以容纳的类型是单一的，只能是字符串类型；不同于列表、相同于元组之处在于字符串不可修改。

## 五、数据容器（序列）的切片

### 5.1 序列

序列是指：内容连续、有序，可使用下标索引的一类数据容器。

列表、元组、字符串均可以视为序列。

![](./images/20251003170800.png)
如上图所示，序列的典型特征就是：有序并可用下标索引。字符串、元组、列表均满足这个要求。

### 5.2 序列的常用操作 - 切片

序列支持切片，即：列表、元组、字符串均支持进行切片操作。

切片：从一个序列中，取出一个子序列。
* 语法：`序列[起始下标:结束下标:步长]`。

切片表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列：
* 起始下标表示从何处开始，可以留空，留空视作从头开始；
* 结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾；
* 步长表示依次取元素的间隔：
  * 步长 1 表示一个个取元素；
  * 步长 2 表示每次跳过 1 个元素取；
  * 步长 N 表示每次跳过 N - 1 个元素取；
  * 步长为负数表示反向取（注意：起始下标和结束下标也要反向标记）。

> 注意：步长默认是 1，所以可以省略不写。
>
> 例如：`my_list[1:4:1]` 可以简写为 `my_list[1:4]`。

需要注意的是，此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）；原因在于元组和字符串不支持元素的修改操作。

序列的切片演示：
* 示例代码 1：
```python
my_list = [1, 2, 3, 4, 5]
new_list = my_list[1:4] # 下标 1 开始，下标 4（不含）结束，步长 1
print(new_list) # 结果：[2, 3, 4]
```
* 示例代码 2：
```python
my_tuple = (1, 2, 3, 4, 5)
new_tuple = my_tuple[:] # 从头开始，到最后结束，步长 1
print(new_tuple)  # 结果：(1, 2, 3, 4, 5)
```
* 示例代码 3：
```python
my_list = [1, 2, 3, 4, 5]
new_list = my_list[::2] # 从头开始，到最后结束，步长 2
print(new_list) # 结果：[1, 3, 5]
```
* 示例代码 4：
```python
my_str = "12345"
new_str = my_str[:4:2]  # 从头开始，到下标 4（不含）结束，步长 2
print(new_str)  # 结果："13"
```
* 示例代码 5：
```python
my_str = "12345"
new_str = my_str[::-1]  # 从头（最后）开始，到尾结束，步长 -1（倒序）
print(new_str)  # 结果："54321"
```
* 示例代码 6：
```python
my_list = [1, 2, 3, 4, 5]
new_list = my_list[3:1:-1]  # 从下标 3 开始，到下标 1（不含）结束，步长 -1（倒序）
print(new_list) # 结果：[4, 3]
```
* 示例代码 7：
```python
my_tuple = (1, 2, 3, 4, 5)
new_tuple = my_tuple[:1:-2] # 从头（最后）开始，到下标 1（不含）结束，步长 -2（倒序）
print(new_tuple)  # 结果：(5, 3)
```

通过上述的示例代码可以看到，切片操作对列表、元组、字符串是通用的；同时非常灵活，根据需求，起始位置、结束位置、步长（正反序）都是可以自行控制的。

## 六、集合（set）

我们目前接触到了列表、元组、字符串三个数据容器了，基本满足大多数的使用场景。为何又需要学习新的集合类型呢？

通过特性来分析：
* 列表可以修改、支持重复元素且有序；
* 元组、字符串不可修改，支持重复元素且有序。

大家有没有看出一些局限？局限就在于：它们都支持重复元素。

如果场景需要对内容做去重处理，列表、元组、字符串就不方便了。

而集合，最主要的特点就是：不支持元素的重复（自带去重功能），并且内容无序。

### 6.1 集合的定义

基本语法：
```python
# 定义集合字面量
{元素, 元素, ..., 元素}
# 定义集合变量
变量名称 = {元素, 元素, ..., 元素}
# 定义空集合
变量名称 = set()
```

示例代码：
```python
names = {"黑马程序员", "传智播客", "itcast", "itheima", "黑马程序员", "传智播客"}
print(names)
```
输出结果：
```python
{'itheima', '黑马程序员', '传智播客', 'itcast'}
```

结果中可见：去重且无序。
* 因为要对元素做去重处理，所以无法保证顺序和创建的时候一致。

### 6.2 集合的常用操作

集合常用功能总结：
| 编号 | 操作 | 说明 |
| :--: | :--: | :--: |
| 1 | `集合.add(元素)` | 集合内添加一个元素 |
| 2 | `集合.remove(元素)` | 移除集合内指定的元素 |
| 3 | `集合.pop()` | 从集合中随机取出一个元素 |
| 4 | `集合.clear()` | 将集合清空 |
| 5 | `集合 1.difference(集合 2)` | 得到一个新集合，内含 2 个集合的差集；原有的 2 个集合内容不变 |
| 6 | `集合 1.difference_update(集合 2)` | 在 `集合 1` 中，删除 `集合 2` 中存在的元素；`集合 1` 被修改，`集合 2` 不变 |
| 7 | `集合 1.union(集合 2)` | 得到 1 个新集合，内含 2 个集合的全部元素；原有的 2 个集合内容不变 |
| 8 | `len(集合)` | 得到一个整数，记录了集合的元素数量 |

#### 6.2.1 修改

首先，因为集合是无序的，所以集合不支持下标索引访问。

> 因此，集合不属于序列。

但是集合和列表一样，是允许修改的。

添加新元素：
* 功能：将指定元素添加到集合内。
* 语法：`集合.add(元素)`。
* 结果：集合本身被修改，添加了新元素。
* 示例代码：
  ```python
  my_set = {"Hello", "World"}
  my_set.add("itheima")
  print(my_set) # 结果：{'Hello', 'itheima', 'World'}
  ```

移除元素：
* 功能：将指定元素从集合内移除。
* 语法：`集合.remove(元素)`。
* 结果：集合本身被修改，移除了元素。
* 示例代码：
  ```python
  my_set = {"Hello", "World", "itheima"}
  my_set.remove("Hello")
  print(my_set) # 结果：{'World', 'itheima'}
  ```

从集合中随机取出元素：
* 功能：从集合中随机取出一个元素
* 语法：`集合.pop()`。
* 结果：会得到一个元素的结果；同时集合本身被修改，该元素被移除。
* 示例代码：
  ```python
  my_set = {"Hello", "World", "itheima"}
  element = my_set.pop()
  print(my_set) # 结果：{'World', 'itheima'}
  print(element)  # 结果：'Hello'
  ```

清空集合：
* 功能：清空集合。
* 语法：`集合.clear()`。
* 结果：集合本身被清空。
* 示例代码：
  ```python
  my_set = {"Hello", "World", "itheima"}
  my_set.clear()
  print(my_set) # 结果：set() 空集合
  ```

取出 2 个集合的差集：
* 功能：取出集合 1 和集合 2 的差集（即集合 1 有而集合 2 没有的）。
* 语法：`集合 1.difference(集合 2)`。
* 结果：得到一个新集合，集合 1 和集合 2 不变。
* 示例代码：
  ```python
  set1 = {1, 2, 3}
  set2 = {1, 5, 6}
  set3 = set1.difference(set2)
  print(set3) # 结果：{2, 3}
  print(set1) # 结果：{1, 2, 3} 不变
  print(set2) # 结果：{1, 5, 6} 不变
  ```

消除 2 个集合的差集：
* 功能：对比集合 1 和集合 2，在集合 1 内，删除和集合 2 相同的元素。
* 语法：`集合 1.difference_update(集合 2)`。
* 结果：集合 1 被修改，集合 2 不变。
* 示例代码：
  ```python
  set1= {1, 2, 3}
  set2 = {1, 5, 6}
  set1.difference_update(set2)
  print(set1) # 结果：{2, 3}
  print(set2) # 结果：{1, 5, 6}
  ```

2 个集合合并：
* 功能：将集合 1 和集合 2 组合成新集合。
* 语法：`集合 1.union(集合 2)`。
* 结果：得到新集合，集合 1 和集合 2 不变。
* 示例代码：
  ```python
  set1 = {1, 2, 3}
  set2 = {1, 5, 6}
  set3 = set1.union(set2)
  print(set3) # 结果：{1, 2, 3, 5, 6} 新集合
  print(set1) # 结果：{1, 2, 3} set1 不变
  print(set2) # 结果：{1, 5, 6} set2 不变
  ```

#### 6.2.2 集合长度

查看集合的元素数量：
* 功能：统计集合内有多少元素。
* 语法：`len(集合)`。
* 结果：得到一个整数结果。
* 示例代码：
  ```python
  set1 = {1, 2, 3}
  print(len(set1))  # 结果：3
  ```

#### 6.2.3 for 循环遍历

集合同样支持使用 `for` 循环遍历：
```python
set1 = {1, 2, 3}
for i in set1:
  print(i)
```
输出结果：
```python
# 结果
1
2
3

```

> 注意：集合不支持下标索引，所以也就不支持使用 `while` 循环。

### 6.3 集合总结

经过上述对集合的学习，可以总结出集合有如下特点：
* 可以容纳多个数据；
* 可以容纳不同类型的数据（混装）；
* 数据是无序存储的（不支持下标索引）；
* 不允许重复数据存在（去重）；
* 可以修改（增加或删除元素等）；
* 支持 `for` 循环。

## 七、字典（dict）

生活中的字典：
![](./images/20251013152559.png)
![](./images/20251013152617.png)
通过【字】就能找到对应的【含义】。所以，我们可以认为，生活中的字典就是记录的一堆：
```python
【字】：【含义】
【字】：【含义】
...
```

Python 中的字典和生活中的字典十分相像：
```python
# Python 中的字典
Key: Value
Key: Value
...
```

生活中的字典可按【字】找出对应的【含义】，而 Python 中的字典可按【`Key`】找出对应的【`Value`】。

为什么需要字典？考虑以下场景：
> 老师有一份名单，记录了学生的姓名和考试总成绩：
> | 姓名 | 成绩 |
> | :--: | :--: |
> | 王力鸿 | 77 |
> | 周杰轮 | 88 |
> | 林俊节 | 99 |
>
> 现在需要将其通过 Python 录入至程序中，并可以通过学生姓名检索学生的成绩。

在以上场景中，使用字典最为合适：
![](./images/20251013153755.png)
可以通过 `Key`（学生姓名）取到对应的 `Value`（考试成绩）。

所以，为什么使用字典？因为可以使用字典，实现用 `Key` 取出 `Value` 的操作。
即：字典可以提供基于 `Key` 检索 `Value` 的场景实现，就像查字典一样。

### 7.1 字典的定义

字典的定义，同样使用 `{}`，不过存储的元素是一个个的键值对，语法如下：
```python
# 定义字典字面量
{key: value, key: value, ..., key: value}
# 定义字典变量
my_dict = {key: value, key: value, ..., key: value}
# 定义空字典
my_dict = {}  # 空字典定义方式 1
my_dict = dict()  # 空字典定义方式 2
```

> 注意：
> 
> 在定义空集合时不可使用以下方式：
> ```python
> my_set = {}
> ```
> 其原因在于：字典在定义空字典时已将 `{}` 占用。

字典定义的注意事项如下：
* 使用 `{}` 存储元素，每一个元素是一个键值对；
* 每一个键值对包含 `Key` 和 `Value`，并使用冒号分隔；
* 键值对之间使用逗号分隔；
* `Key` 和 `Value` 可以是任意类型的数据，但 `Key` 不可为字典；
* `Key` 不可重复，重复会对原有的前一个数据覆盖。

前面场景中记录学生成绩的需求，可以如下记录：
```python
stu_score = {"王力鸿": 99, "周杰轮": 88, "林俊节": 77}
```

### 7.2 字典数据的获取

字典同集合一样，不可以使用下标索引。

但是字典可以通过 `Key` 值来取得对应的 `Value`：
```python
# 语法：字典[Key] 可以取到对应的 Value
stu_score = {"王力鸿": 99, "周杰轮": 88, "林俊节": 77}
print(stu_score["王力鸿"])  # 结果：99
print(stu_score["周杰轮"])  # 结果：88
print(stu_score["林俊节"])  # 结果：77
```

### 7.3 字典的嵌套

字典的 `Key` 和 `Value` 可以是任意数据类型（`Key` 不可为字典），那么就表明字典是可以嵌套的。

需求如下：
> 记录学生各科的考试信息：
> | 姓名 | 语文 | 数学 | 英语 |
> | :--: | :--: | :--: | :--: |
> | 王力鸿 | 77 | 66 | 33 |
> | 周杰轮 | 88 | 86 | 55 |
> | 林俊节 | 99 | 96 | 66 |
示例代码：
```python
stu_score = {"王力鸿": {"语文": 77, "数学": 66, "英语": 33}, "周杰轮": {"语文": 88, "数学": 86, "英语": 55}, "林俊节": {"语文": 99, "数学": 96, "英语": 66}}
```
优化一下可读性，可以写成：
```python
stu_score = {
  "王力鸿": {"语文": 77, "数学": 66, "英语": 33},
  "周杰轮": {"语文": 88, "数学": 86, "英语": 55},
  "林俊节": {"语文": 99, "数学": 96, "英语": 66}
}
```

嵌套字典的内容获取，如下所示：
```python
stu_score = {
  "王力鸿": {"语文": 77, "数学": 66, "英语": 33},
  "周杰轮": {"语文": 88, "数学": 86, "英语": 55},
  "林俊节": {"语文": 99, "数学": 96, "英语": 66}
}
print(stu_score["王力鸿"])  # 结果：{"语文": 77, "数学": 66, "英语": 33}
print(stu_score["王力鸿"]["语文"])  # 结果：77
print(stu_score["周杰轮"]["数学"])  # 结果：86
```

### 7.4 字典的常用操作

新增元素：
* 语法：`字典[Key] = Value`。
* 结果：字典被修改，新增了元素。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  # 新增：张学油的考试成绩
  stu_score['张学油'] = 66
  print(stu_score)  # 结果：{'王力鸿': 77, '周杰轮': 88, '林俊节': 99, '张学油': 66}
  ```

更新元素：
* 语法：`字典[Key] = Value`。
* 结果：字典被修改，元素被更新。
> 注意：字典 `Key` 不可以重复，所以对已存在的 `Key` 执行上述操作，就是更新 `Value` 值。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  # 更新：王力鸿的考试成绩
  stu_score['王力鸿'] = 100
  print(stu_score)  # 结果：{'王力鸿': 100, '周杰轮': 88, '林俊节': 99}
  ```

删除元素：
* 语法：`字典.pop(Key)`。
* 结果：获得指定 `Key` 的 `Value`；同时字典被修改，指定 `Key` 的数据被删除。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  value = stu_score.pop("王力鸿")
  print(value)  # 结果：77
  print(stu_score)  # 结果：{"周杰轮": 88, "林俊节": 99}
  ```

清空字典：
* 语法：`字典.clear()`。
* 结果：字典被修改，元素被清空。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  stu_score.clear()
  print(stu_score)  # 结果：{}
  ```

获取全部的 Key：
* 语法：`字典.keys()`。
* 结果：得到字典中的全部 `Key`。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  keys = stu_score.keys()
  print(keys) # 结果：dict_keys(['王力鸿', '周杰轮', '林俊节'])
  ```

遍历字典：
* 方式 1 - 通过获取到全部的 `key` 来完成遍历：
  * 语法：`for key in 字典.keys()`。
  * 示例代码：
    ```python
    # 获取全部的 key
    my_dict = {"周杰轮": 99, "林俊节": 88, "张学油": 77}
    keys = my_dict.keys()
    print(f"字典的全部 keys 是：{keys}")

    # 遍历字典
    # 方式 1：通过获取到全部的 key 来完成遍历
    for key in keys:
        print(f"字典的 key 是：{key}")
        print(f"字典的 value 是：{my_dict[key]}")
    ```
* 方式 2 - 直接对字典进行 `for` 循环，每一次循环都是直接得到 `key`：
  * 语法：`for key in 字典`。
  * 示例代码：
    ```python
    my_dict = {"周杰轮": 99, "林俊节": 88, "张学油": 77}
    # 遍历字典
    # 方式 2：直接对字典进行 for 循环，每一次循环都是直接得到 key
    for key in my_dict:
        print(f"字典的 key 是：{key}")
        print(f"字典的 value 是：{my_dict[key]}")
    ```
> 注意：字典不支持下标索引，所以同样不可以用 `while` 循环遍历。

计算字典内的全部元素（键值对）数量：
* 语法：`len(字典)`。
* 结果：得到一个整数，表示字典内元素（键值对）的数量。
* 示例代码：
  ```python
  stu_score = {
    "王力鸿": 77,
    "周杰轮": 88,
    "林俊节": 99
  }
  print(len(stu_score)) # 结果：3
  ```

字典的常用操作总结：
| 编号 | 操作 | 说明 |
| :--: | :--: | :--: |
| 1 | `字典[Key]` | 获取指定 `Key` 对应的 `Value` 值 |
| 2 | `字典[Key] = Value` | 添加或更新键值对 |
| 3 | `字典.pop(Key)` | 取出 `Key` 对应的 `Value` 并在字典内删除此 `Key` 的键值对 |
| 4 | `字典.clear()` | 清空字典 |
| 5 | `字典.keys()` | 获取字典的全部 `Key`，可用于 `for` 循环遍历字典 |
| 6 | `len(字典)` | 计算字典内的元素数量 |

### 7.5 字典总结

经过上述对字典的学习，可以总结出字典有如下特点：
* 可以容纳多个数据；
* 可以容纳不同类型的数据；
* 每一份数据是 `Key - Value` 键值对；
* 可以通过 `Key` 获取到 `Value`，且 `Key` 不可重复（重复会覆盖）；
* 不支持下标索引；
* 可以修改（增加、删除或更新元素等）；
* 支持 `for` 循环，不支持 `while` 循环。

## 八、5 类数据容器的总结对比

### 8.1 数据容器分类

数据容器可以从以下视角进行简单的分类：
* 是否支持下标索引：
  * 支持：列表、元组、字符串 -> 序列类型；
  * 不支持：集合、字典 -> 非序列类型。
* 是否支持重复元素：
  * 支持：列表、元组、字符串 -> 序列类型；
  * 不支持：集合、字典 -> 非序列类型。
* 是否可以修改：
  * 支持：列表、集合、字典；
  * 不支持：元组、字符串。

### 8.2 数据容器特点对比

5 类数据容器的特点对比如下：
|  | 列表 | 元组 | 字符串 | 集合 | 字典 |
| :--: | :--: | :--: | :--: | :--: | :--: |
| 元素数量 | 支持多个 | 支持多个 | 支持多个 | 支持多个 | 支持多个 |
| 元素类型 | 任意 | 任意 | 仅字符 | 任意 | `Key: Value`（`Key`：除字典外任意类型；`Value`：任意类型） |
| 下标索引 | 支持 | 支持 | 支持 | 不支持 | 不支持 |
| 重复元素 | 支持 | 支持 | 支持 | 不支持 | 不支持 |
| 可修改性 | 支持 | 不支持 | 不支持 | 支持 | 支持 |
| 数据有序 | 是 | 是 | 是 | 否 | 否 |
| 使用场景 | 可修改、可重复的一批数据记录场景 | 不可修改、可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复（即去重）的一批数据记录场景 | 以 `Key` 检索 `Value` 的一批数据记录场景 |

## 九、数据容器的通用操作

数据容器尽管各自有各自的特点，但是它们也有通用的一些操作。

容器通用功能总览：
| 功能 | 描述 |
| :--: | :--: |
| 通用 `for` 循环 | 遍历容器（字典是遍历 `key`） |
| `max()` | 容器内最大元素 |
| `min()` | 容器内最小元素 |
| `len()` | 容器元素个数 |
| `list()` | 转换为列表 |
| `tuple()` | 转换为元组 |
| `str()` | 转换为字符串 |
| `set()` | 转换为集合 |
| `sorted(序列, [reverse=True])` | 排序，其中 `reverse=True` 表示降序；得到一个排好序的列表 |

示例代码：
```python
"""
演示数据容器的通用功能
"""
my_list = [1, 2, 3, 4, 5]
my_tuple = (1, 2, 3, 4, 5)
my_str = "abcdefg"
my_set = {1, 2, 3, 4, 5}
my_dict = {"key1": 1, "key2": 2, "key3": 3, "key4": 4, "key5": 5}

# len 元素个数
print(f"列表 元素个数有：{len(my_list)}")
print(f"元组 元素个数有：{len(my_tuple)}")
print(f"字符串 元素个数有：{len(my_str)}")
print(f"集合 元素个数有：{len(my_set)}")
print(f"字典 元素个数有：{len(my_dict)}")

# max 最大元素
print(f"列表 最大的元素是：{max(my_list)}")
print(f"元组 最大的元素是：{max(my_tuple)}")
print(f"字符串 最大的元素是：{max(my_str)}")
print(f"集合 最大的元素是：{max(my_set)}")
print(f"字典 最大的元素是：{max(my_dict)}")

# min 最小元素
print(f"列表 最小的元素是：{min(my_list)}")
print(f"元组 最小的元素是：{min(my_tuple)}")
print(f"字符串 最小的元素是：{min(my_str)}")
print(f"集合 最小的元素是：{min(my_set)}")
print(f"字典 最小的元素是：{min(my_dict)}")

# 类型转换：容器转列表
print(f"列表转列表的结果是：{list(my_list)}")
print(f"元组转列表的结果是：{list(my_tuple)}")
print(f"字符串转列表的结果是：{list(my_str)}")
print(f"集合转列表的结果是：{list(my_set)}")
print(f"字典转列表的结果是：{list(my_dict)}")

# 类型转换：容器转元组
print(f"列表转元组的结果是：{tuple(my_list)}")
print(f"元组转元组的结果是：{tuple(my_tuple)}")
print(f"字符串转元组的结果是：{tuple(my_str)}")
print(f"集合转元组的结果是：{tuple(my_set)}")
print(f"字典转元组的结果是：{tuple(my_dict)}")

# 类型转换：容器转字符串
print(f"列表转字符串的结果是：{str(my_list)}")
print(f"元组转字符串的结果是：{str(my_tuple)}")
print(f"字符串转字符串的结果是：{str(my_str)}")
print(f"集合转字符串的结果是：{str(my_set)}")
print(f"字典转字符串的结果是：{str(my_dict)}")

# 类型转换：容器转集合
print(f"列表转集合的结果是：{set(my_list)}")
print(f"元组转集合的结果是：{set(my_tuple)}")
print(f"字符串转集合的结果是：{set(my_str)}")
print(f"集合转集合的结果是：{set(my_set)}")
print(f"字典转集合的结果是：{set(my_dict)}")

# 进行容器的排序
my_list = [3, 1, 2, 5, 4]
my_tuple = (3, 1, 2, 5, 4)
my_str = "bdcefga"
my_set = {3, 1, 2, 5, 4}
my_dict = {"key3": 1, "key1": 2, "key2": 3, "key5": 4, "key4": 5}

print(f"列表对象的排序结果：{sorted(my_list)}")
print(f"元组对象的排序结果：{sorted(my_tuple)}")
print(f"字符串对象的排序结果：{sorted(my_str)}")
print(f"集合对象的排序结果：{sorted(my_set)}")
print(f"字典对象的排序结果：{sorted(my_dict)}")

print(f"列表对象的反向排序结果：{sorted(my_list, reverse=True)}")
print(f"元组对象的反向排序结果：{sorted(my_tuple, reverse=True)}")
print(f"字符串对象的反向排序结果：{sorted(my_str, reverse=True)}")
print(f"集合对象的反向排序结果：{sorted(my_set, reverse=True)}")
print(f"字典对象的反向排序结果：{sorted(my_dict, reverse=True)}")
```

### 9.1 数据容器的通用操作 - 遍历

首先，在遍历上：
* 5 类数据容器都支持 `for` 循环遍历；
* 列表、元组、字符串支持 `while` 循环，集合、字典不支持（无法下标索引）。

尽管遍历的形式各有不同，但是它们都支持遍历操作。

### 9.2 数据容器的通用统计功能

除了遍历这个共性外，数据容器可以通用非常多的功能方法：
* `len(容器)`：
  * 功能：统计容器的元素个数。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_tuple = (1, 2, 3, 4, 5)
    my_str = "itheima"

    print(len(my_list)) # 结果：3
    print(len(my_tuple))  # 结果：5
    print(len(my_str))  # 结果：7
    ```
* `max(容器)`：
  * 功能：统计容器的最大元素。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_tuple = (1, 2, 3, 4, 5)
    my_str = "itheima"

    print(max(my_list)) # 结果：3
    print(max(my_tuple))  # 结果：5
    print(max(my_str))  # 结果：t
    ```
* `min(容器)`：
  * 功能：统计容器的最小元素。
  * 示例代码：
    ```python
    my_list = [1, 2, 3]
    my_tuple = (1, 2, 3, 4, 5)
    my_str = "itheima"

    print(min(my_list)) # 结果：1
    print(min(my_tuple))  # 结果：1
    print(min(my_str))  # 结果：a
    ```

### 9.3 容器的通用转换功能

除了下标索引这个共性外，还可以通用类型转换：
* `list(容器)`：将给定容器转换为列表。
* `str(容器)`：将给定容器转换为字符串。
* `tuple(容器)`：将给定容器转换为元组。
* `set(容器)`：将给定容器转换为集合。

> 注意：虽然存在字典转换函数 `dict()`，但是将其他类型的容器通过 `dict()` 进行转换时会报错，因为无法凭空产生 `Value` 值；同时，通过 `str()` 将字典转换为字符串后原字典的 `Value` 值将会保存下来，除此之外将字典转换为除字典本身的其他类型的容器后原字典的 `Value` 值均将会丢失。

### 9.4 容器通用排序功能

通用排序功能：
* `sorted(容器, [reverse=True])`；
  * 功能：将给定容器进行排序。

> 注意：排序后都会得到列表（`list`）对象。

## 十、字符串大小比较的方式

### 10.1 ASCII 码表

在程序中，字符串所用的所有字符如大小写英文单词、数字、特殊符号（`!`、`\`、`|`、`@`、`#`、`空格` 等）都有其对应的 ASCII 码表值。

ASCII 码表如下所示：
![](./images/20251023213724.png "")

每一个字符都能对应上一个数字的码值。

单个字符之间如何确定大小？通过 ASCII 码表，确定字符对应的码值数字来确定大小。

字符串进行比较就是基于数字的码值大小进行比较的。

### 10.2 字符串比较

字符串是按位比较，也就是一位位进行对比；只要有一位大，那么整体就大。

即：字符串如何比较？从头到尾，一位位进行比较；其中一位大，后面就无需比较了。

示例情况 1：
![](./images/20251023214033.png "")

示例情况 2：
![](./images/20251023214252.png "")